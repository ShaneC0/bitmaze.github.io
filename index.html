<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>bitMaze Generator</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.min.js"></script>
</head>

<body>
    <script>
        function genTokenData(projectNum) {
            let data = {};
            let hash = "0x";
            for (var i = 0; i < 64; i++) {
                hash += Math.floor(Math.random() * 16).toString(16);
            }
            data.hash = hash;
            data.tokenId = (projectNum * 1000000 + Math.floor(Math.random() * 1000)).toString();
            return data;
        }
        let tokenData = genTokenData(123);
    </script>
    <script>
        const CANVAS_SIZE = 500; class Random { constructor() { this.useA = !1; let e = function (e) { let t = parseInt(e.substr(0, 8), 16), a = parseInt(e.substr(8, 8), 16), r = parseInt(e.substr(16, 8), 16), s = parseInt(e.substr(24, 8), 16); return function () { let e = ((t |= 0) + (a |= 0) | 0) + (s |= 0) | 0; return s = s + 1 | 0, t = a ^ a >>> 9, a = (r |= 0) + (r << 3) | 0, r = (r = r << 21 | r >>> 11) + e | 0, (e >>> 0) / 4294967296 } }; this.prngA = new e(tokenData.hash.substr(2, 32)), this.prngB = new e(tokenData.hash.substr(34, 32)); for (let e = 0; e < 1e6; e += 2)this.prngA(), this.prngB() } random_dec() { return this.useA = !this.useA, this.useA ? this.prngA() : this.prngB() } random_num(e, t) { return e + (t - e) * this.random_dec() } random_int(e, t) { return Math.floor(this.random_num(e, t + 1)) } random_bool(e) { return this.random_dec() < e } random_choice(e) { return e[this.random_int(0, e.length - 1)] } } const hashPairs = []; for (let e = 0; e < 32; e++)hashPairs.push(tokenData.hash.slice(2 + 2 * e, 4 + 2 * e)); const decPairs = hashPairs.map(e => parseInt(e, 16)); let R = new Random, getCellCount = () => { let e = R.random_int(96, 200); for (; e % 32 != 0;)e = R.random_int(96, 200); return e }, palettes = [["#c6ffdd", "#d0f8ce", "#e1ebb1", "#f9d98a", "#fac684", "#f9a881", "#f88f7f", "#f77a7d"], ["#00f160", "#01e86b", "#01cf85", "#02bd98", "#03aaad", "#0496c3", "#058ad0", "#057ae2"], ["#ff9566", "#ff8a65", "#ff8665", "#ff7d64", "#ff7463", "#ff6d63", "#ff6463", "#ff5f62"], ["#fa03ff", "#c72df8", "#a64bf4", "#8568ef", "#5d8aea", "#3aa8e5", "#1cc2e1", "#07d4de"], ["#cbf4cd", "#d7ebb9", "#e3e3a7", "#efdb94", "#f7cc86", "#f5b583", "#f49f80", "#f3877f"]], metadata = { cellCount: getCellCount(), mazeCount: R.random_choice([4, 16]), visitedPallet: R.random_choice(palettes), unvisitedPallet: R.random_choice(palettes), shortestPathPallet: R.random_choice(palettes), pathfinder: R.random_choice([dijkstra, aStar, depthFirstSearch, breadthFirstSearch]), direction: R.random_choice(["diagonal", "horizontal", "vertical"]) }; function createGrid(e) { let t = []; for (let a = 0; a < e; a++)for (let r = 0; r < e; r++)t.push({ x: r, y: a, visitedGenerator: !1, visitedSolver: !1, walls: { up: !0, down: !0, left: !0, right: !0 }, distance: 1 / 0, heuristicDistance: 1 / 0, previous: null, isShortestPath: !1 }); return t } function findEndPoints(e) { let t = []; for (let a = 0; a < mazesPerRow; a++)for (let r = 0; r < mazesPerRow; r++)switch (metadata.direction) { case "diagonal": t.push([e[IX(r * cellsPerMaze, a * cellsPerMaze)], e[IX(r * cellsPerMaze + cellsPerMaze - 1, a * cellsPerMaze + cellsPerMaze - 1)]]); break; case "horizontal": t.push([e[IX(r * cellsPerMaze, a * cellsPerMaze + cellsPerMaze / 2)], e[IX(r * cellsPerMaze + cellsPerMaze - 1, a * cellsPerMaze + cellsPerMaze / 2)]]); break; case "vertical": t.push([e[IX(r * cellsPerMaze + cellsPerMaze / 2, a * cellsPerMaze)], e[IX(r * cellsPerMaze + cellsPerMaze / 2, a * cellsPerMaze + cellsPerMaze - 1)]]) }return t } function drawGrid(e, t, a, r, s, l, i) { e.map(e => { if (e.x > r && e.x < s && e.y > l && e.y < i) if (e.isShortestPath) { let a = Math.sqrt(Math.pow(metadata.cellCount / mazesPerRow, 2) + Math.pow(metadata.cellCount / mazesPerRow, 2)), r = Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)), s = Math.floor(r / a * 7); stroke(metadata.shortestPathPallet[s]), fill(metadata.shortestPathPallet[s]), circle(e.x * pxLength + pxLength / 2, e.y * pxLength + pxLength / 2, pxLength / 2) } else if (e.visitedSolver) { let t = Math.sqrt(Math.pow(metadata.cellCount / mazesPerRow, 2) + Math.pow(metadata.cellCount / mazesPerRow, 2)), r = Math.sqrt(Math.pow(e.x - a.x, 2) + Math.pow(e.y - a.y, 2)), s = Math.floor(r / t * 7); stroke(metadata.visitedPallet[s]), fill(metadata.visitedPallet[s]), circle(e.x * pxLength + pxLength / 2, e.y * pxLength + pxLength / 2, pxLength / 2) } else { let t = metadata.cellCount * Math.sqrt(2) / 2, a = Math.sqrt(Math.pow(e.x - metadata.cellCount / 2, 2) + Math.pow(e.y - metadata.cellCount / 2, 2)), r = Math.floor(a / t * 7); stroke(metadata.unvisitedPallet[r]), fill(metadata.unvisitedPallet[r]), circle(e.x * pxLength + pxLength / 2, e.y * pxLength + pxLength / 2, pxLength / 2 - 1) } }) } function drawGrids(e, t) { let a = 0; for (let r = 0; r < mazesPerRow; r++)for (let s = 0; s < mazesPerRow; s++)drawGrid(e, t[a][0], t[a][1], s * cellsPerMaze - 1, (s + 1) * cellsPerMaze, r * cellsPerMaze - 1, (r + 1) * cellsPerMaze), a++ } function findNeighbors(e, t, a, r, s, l, i) { let n = []; return i ? (t.y > s && !t.walls.up && n.push(e[IX(t.x, t.y - 1)]), t.y < l && !t.walls.down && n.push(e[IX(t.x, t.y + 1)]), t.x > a && !t.walls.left && n.push(e[IX(t.x - 1, t.y)]), t.x < r && !t.walls.right && n.push(e[IX(t.x + 1, t.y)]), n = n.filter(e => !e.visitedSolver)) : (t.y > s && n.push(e[IX(t.x, t.y - 1)]), t.y < l && n.push(e[IX(t.x, t.y + 1)]), t.x > a && n.push(e[IX(t.x - 1, t.y)]), t.x < r && n.push(e[IX(t.x + 1, t.y)]), n = n.filter(e => !e.visitedGenerator)), n } function randomizedDFS(e, t, a, r, s, l) { let i = []; for (t.visitedGenerator = !0, i.push(t); i.length > 0;) { let t = i.pop(), n = findNeighbors(e, t, a, r, s, l, !1); if (n.length > 0) { i.push(t); let e = n[R.random_int(0, n.length - 1)]; t.x < e.x ? (t.walls.right = !1, e.walls.left = !1) : t.x > e.x ? (t.walls.left = !1, e.walls.right = !1) : t.y < e.y ? (t.walls.down = !1, e.walls.up = !1) : t.y > e.y && (t.walls.up = !1, e.walls.down = !1), e.visitedGenerator = !0, i.push(e) } } } function createMazes(e, t) { let a = 0; for (let r = 0; r < mazesPerRow; r++)for (let s = 0; s < mazesPerRow; s++)randomizedDFS(e, t[a][0], s * cellsPerMaze, (s + 1) * cellsPerMaze - 1, r * cellsPerMaze, (r + 1) * cellsPerMaze - 1), a++ } function dijkstra(e, t, a, r, s, l, i) { let n = e.slice(), o = n[IX(t.x, t.y)]; for (o.distance = 0; n.length > 0;) { if (o.x == a.x && o.y == a.y) return !0; let t = findNeighbors(e, o, r, s, l, i, !0); for (let e = 0; e < t.length; e++) { let a = o.distance + 1; t[e].previous = o, a < t[e].distance && (t[e].distance = a) } o.visitedSolver = !0, n.filter(e => !e.visitedSolver), n.sort((e, t) => e.distance - t.distance), o = n.shift() } } function heuristic(e, t) { return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2)) } function aStar(e, t, a, r, s, l, i) { t.distance = 0, t.heuristicDistance = heuristic(t, a); let n = [t]; for (; n.length > 0;) { let t = (n = n.sort((e, t) => e.heuristicDistance - t.heuristicDistance)).shift(); if (t.visitedSolver = !0, t.x == a.x && t.y == a.y) return !0; let o = findNeighbors(e, t, r, s, l, i, !0); for (let e = 0; e < o.length; e++) { let r = t.distance + 1; r < o[e].distance && (o[e].distance = r, o[e].heuristicDistance = r + heuristic(o[e], a), o[e].previous = t, n.includes(o[e]) || n.push(o[e])) } } } function depthFirstSearch(e, t, a, r, s, l, i) { let n = []; for (n.push(t); n.length > 0;) { let t = n.pop(); if (t.x == a.x && t.y == a.y) return !0; if (!t.visitedSolver) { t.visitedSolver = !0; let a = findNeighbors(e, t, r, s, l, i, !0); for (let e = 0; e < a.length; e++)a[e].previous = t, n.push(a[e]) } } } function breadthFirstSearch(e, t, a, r, s, l, i) { let n = []; for (t.visitedSolver = !0, n.unshift(t); n.length > 0;) { let t = n.pop(); if (t.x == a.x && t.y == a.y) return !0; let o = findNeighbors(e, t, r, s, l, i, !0); for (let e = 0; e < o.length; e++)o[e].visitedSolver = !0, o[e].previous = t, n.unshift(o[e]) } } function solveMazes(e, t) { let a = 0; for (let r = 0; r < mazesPerRow; r++)for (let s = 0; s < mazesPerRow; s++)metadata.pathfinder(e, t[a][0], t[a][1], s * cellsPerMaze, (s + 1) * cellsPerMaze - 1, r * cellsPerMaze, (r + 1) * cellsPerMaze - 1), a++ } function constructShortestPaths(e) { for (let t = 0; t < e.length; t++) { let a = e[t][1]; for (; a.previous;)a.isShortestPath = !0, a = a.previous; a.isShortestPath = !0 } } console.log(metadata); let IX = (e, t) => t * metadata.cellCount + e, pxLength = CANVAS_SIZE / metadata.cellCount, mazesPerRow = Math.sqrt(metadata.mazeCount), cellsPerMaze = metadata.cellCount / mazesPerRow, grid = createGrid(metadata.cellCount), endPoints = findEndPoints(grid); createMazes(grid, endPoints), solveMazes(grid, endPoints), constructShortestPaths(endPoints); for (let e = 0; e < grid.length; e++)grid[e].walls.up = !1, grid[e].walls.down = !1, grid[e].walls.left = !1, grid[e].walls.right = !1; function setup() { createCanvas(CANVAS_SIZE, CANVAS_SIZE), drawGrids(grid, endPoints) } function draw() { }
    </script>
</body>

</html>